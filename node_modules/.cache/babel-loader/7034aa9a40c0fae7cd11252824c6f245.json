{"ast":null,"code":"import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar GestureFlag;\n\n(function (GestureFlag) {\n  GestureFlag[\"OnStart\"] = \"start\";\n  GestureFlag[\"OnChange\"] = \"change\";\n  GestureFlag[\"OnEnd\"] = \"end\";\n})(GestureFlag || (GestureFlag = {})); // blank function\n\n\nvar noop = function noop() {}; // returns a function that chains all functions given as parameters\n\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n}; // vector add\n\n\nvar addV = function addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n}; // vector substract\n\n\nvar subV = function subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n};\n\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var type = _ref[0],\n          fn = _ref[1];\n      return el[action](type, fn, options);\n    });\n  };\n};\n\nvar addListeners =\n/*#__PURE__*/\nsetListeners(true);\nvar removeListeners =\n/*#__PURE__*/\nsetListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets scroll event data\r\n * @param event\r\n * @returns scroll event data\r\n */\n\n\nfunction getScrollEventData(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return _extends({\n    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets wheel event data\r\n * @param event\r\n * @returns wheel event data\r\n */\n\n\nfunction getWheelEventData(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return _extends({\n    values: [deltaX, deltaY]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets pointer event data\r\n * @param event\r\n * @returns pointer event data\r\n */\n\n\nfunction getPointerEventData(event) {\n  var touches = event.touches,\n      buttons = event.buttons,\n      changedTouches = event.changedTouches;\n  var touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;\n\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n\n  var down = touchEvents && touchEvents.length > 0 || buttons > 0;\n  return _extends({\n    values: [clientX, clientY],\n    touches: touchEvents && touchEvents.length || 0,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return _extends({\n    values: da,\n    origin: origin,\n    touches: 2,\n    down: touches.length > 0\n  }, getModifierKeys(event));\n}\n/**\r\n * Calculates velocity\r\n * @param diff the difference between current and previous vectors\r\n * @param delta_t the time delta\r\n * @param len the length of the diff vector\r\n * @returns velocity\r\n */\n\n\nfunction calculateVelocity(diff, delta_t, len) {\n  len = len || Math.hypot.apply(Math, diff);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param diff the previous value\r\n * @param delta_t the time delta\r\n * @returns velocities vector\r\n */\n\n\nfunction calculateVelocities(diff, delta_t) {\n  return delta_t ? diff.map(function (v) {\n    return v / delta_t;\n  }) : Array(diff.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param delta the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(delta) {\n  return Math.hypot.apply(Math, delta);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param diff\r\n * @param len\r\n * @returns direction\r\n */\n\n\nfunction calculateDirection(diff, len) {\n  len = len || Math.hypot.apply(Math, diff) || 1;\n  return diff.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param delta the difference between current and initial vectors\r\n * @param diff the difference between current and previous vectors\r\n * @param delta_t the time delta between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(delta, diff, delta_t) {\n  var len = Math.hypot.apply(Math, diff);\n  return {\n    velocities: calculateVelocities(diff, delta_t),\n    velocity: calculateVelocity(diff, delta_t, len),\n    distance: calculateDistance(delta),\n    direction: calculateDirection(diff, len)\n  };\n}\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction supportsGestureEvent() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Some gestures might use the state key from another gesture (i.e. hover)\r\n * so mappedKeys is a commodity object to get the state key and handler key\r\n * for every gesture\r\n */\n\n\nvar mappedKeys = {\n  drag: {\n    stateKey: 'drag',\n    handlerKey: 'onDrag'\n  },\n  pinch: {\n    stateKey: 'pinch',\n    handlerKey: 'onPinch'\n  },\n  move: {\n    stateKey: 'move',\n    handlerKey: 'onMove'\n  },\n  scroll: {\n    stateKey: 'scroll',\n    handlerKey: 'onScroll'\n  },\n  wheel: {\n    stateKey: 'wheel',\n    handlerKey: 'onWheel'\n  },\n  hover: {\n    stateKey: 'move',\n    handlerKey: 'onHover'\n  }\n}; // default config (will extend user config)\n\nvar defaultConfig = {\n  domTarget: undefined,\n  event: {\n    passive: true,\n    capture: false\n  },\n  pointerEvents: false,\n  window: typeof window !== 'undefined' ? window : undefined,\n  transform: {\n    x: function x(_x) {\n      return _x;\n    },\n    y: function y(_y) {\n      return _y;\n    }\n  },\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true\n}; // common initial state for all gestures\n\nvar initialCommon = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  velocities: [0, 0],\n  delta: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  transform: undefined,\n  local: [0, 0],\n  lastLocal: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined\n}; // initial state for coordinates-based gestures\n\nvar initialCoordinates = {\n  xy: [0, 0],\n  vxvy: [0, 0],\n  velocity: 0,\n  distance: 0,\n  direction: [0, 0]\n}; // xy coordinates\n// initial state for distance and angle-based gestures (pinch)\n\nvar initialDistanceAngle = {\n  da: [0, 0],\n  vdva: [0, 0],\n  origin: [0, 0],\n  turns: 0\n}; // distance and angle\n// initial state object (used by the gesture controller)\n\nvar initialState = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  },\n  move: _extends({}, initialCommon, {}, initialCoordinates),\n  drag: _extends({}, initialCommon, {}, initialCoordinates),\n  scroll: _extends({}, initialCommon, {}, initialCoordinates),\n  wheel: _extends({}, initialCommon, {}, initialCoordinates),\n  pinch: _extends({}, initialCommon, {}, initialDistanceAngle)\n}; // generic end state for all gestures\n\nvar genericEndState = {\n  first: false,\n  last: true,\n  active: false\n};\n/**\r\n * Recognizer abstract class\r\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\nvar Recognizer =\n/**\r\n * Creates an instance of a gesture recognizer.\r\n * @param gestureKey drag, move, hover, pinch, etc.\r\n * @param controller the controller attached to the gesture\r\n * @param [args] the args that should be passed to the gesture handler\r\n */\nfunction Recognizer(gestureKey, controller, args) {\n  var _this = this;\n\n  if (args === void 0) {\n    args = [];\n  }\n\n  this.gestureKey = gestureKey;\n  this.controller = controller;\n  this.args = args;\n\n  this.isEnabled = function () {\n    return _this.controller.config.enabled && _this.controller.config[_this.gestureKey];\n  }; // convenience method to set a timeout for a given gesture\n\n\n  this.setTimeout = function (callback, ms) {\n    var _window;\n\n    if (ms === void 0) {\n      ms = 140;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n  }; // convenience method to clear a timeout for a given gesture\n\n\n  this.clearTimeout = function () {\n    clearTimeout(_this.controller.timeouts[_this.stateKey]);\n  }; // get the controller state for a given gesture\n\n\n  this.getState = function () {\n    return _this.controller.state[_this.stateKey];\n  }; // get the controller shared state\n\n\n  this.getSharedState = function () {\n    return _this.controller.state.shared;\n  }; // does the controller config has pointer events enabled\n\n\n  this.pointerEventsEnabled = function () {\n    return _this.controller.config.pointerEvents;\n  }; // gets the transform config of the controller\n\n\n  this.getTransformConfig = function () {\n    return _this.controller.config.transform;\n  }; // convenience method to add window listeners for a given gesture\n\n\n  this.addWindowListeners = function (listeners) {\n    _this.controller.addWindowListeners(_this.stateKey, listeners);\n  }; // convenience method to remove window listeners for a given gesture\n\n\n  this.removeWindowListeners = function () {\n    _this.controller.removeWindowListeners(_this.stateKey);\n  };\n  /**\r\n   * convenience method to update the controller state for a given gesture\r\n   * @param sharedState shared partial state object\r\n   * @param gestureState partial state object for the gesture handled by the recognizer\r\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\r\n   */\n\n\n  this.updateState = function (sharedState, gestureState, gestureFlag) {\n    _this.controller.updateState(sharedState, gestureState, _this.gestureKey, gestureFlag);\n  };\n  /**\r\n   * returns the start state for a given gesture\r\n   * @param values the values of the start state\r\n   * @param event the event that triggers the gesture start\r\n   */\n\n\n  this.getStartState = function (values, event) {\n    var state = _this.getState();\n\n    var initial = initialState[_this.stateKey];\n\n    var transform = state.transform || event.transform || _this.getTransformConfig();\n\n    var lastLocal = state.local || initial.local;\n    return _extends({}, initial, {\n      event: event,\n      values: values,\n      initial: values,\n      previous: values,\n      local: lastLocal,\n      lastLocal: lastLocal,\n      first: true,\n      active: true,\n      transform: transform,\n      time: event.timeStamp,\n      args: _this.args\n    });\n  }; // mapping this.stateKey to the state key the gesture handles\n  // (ie hover actually deals with the move gesture state)\n\n\n  this.stateKey = mappedKeys[gestureKey].stateKey;\n};\n/**\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\n\nvar CoordinatesRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    var _this;\n\n    _this = _Recognizer.apply(this, arguments) || this;\n    /**\r\n     * Utility function to get kinematics of the gesture\r\n     * @values values we want to calculate the kinematics from\r\n     * @event\r\n     * @returns set of values including delta, velocity, velocities, distance and direction\r\n     */\n\n    _this.getKinematics = function (values, event) {\n      // we get the gesture specific state\n      var state = _this.getState();\n\n      var xy = state.values,\n          initial = state.initial,\n          lastLocal = state.lastLocal,\n          _state$time = state.time,\n          time = _state$time === void 0 ? 0 : _state$time;\n\n      var transform = state.transform || event.transform || _this.getTransformConfig(); // delta is the difference between the current and initial value vectors\n\n\n      var delta = subV(values, initial).map(function (v, i) {\n        return Object.values(transform)[i](v);\n      }); // diff is the difference between the current and previous value vectors\n\n      var diff = subV(values, xy).map(function (v, i) {\n        return Object.values(transform)[i](v);\n      });\n      var delta_t = event.timeStamp - time;\n\n      var _calculateAllKinemati = calculateAllKinematics(delta, diff, delta_t),\n          velocity = _calculateAllKinemati.velocity,\n          velocities = _calculateAllKinemati.velocities,\n          distance = _calculateAllKinemati.distance,\n          direction = _calculateAllKinemati.direction;\n\n      return {\n        event: event,\n        values: values,\n        delta: delta,\n        velocity: velocity,\n        velocities: velocities,\n        distance: distance,\n        direction: direction,\n        local: addV(lastLocal, delta),\n        previous: xy,\n        transform: transform,\n        time: event.timeStamp\n      };\n    };\n\n    return _this;\n  }\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar DragRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled()) return;\n\n      var _getPointerEventData = getPointerEventData(event),\n          values = _getPointerEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData, [\"values\"]); // making sure we're not dragging the element when more than one finger press the screen\n\n\n      if (rest.touches > 1) return;\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId;\n\n      if (_this.pointerEventsEnabled()) {\n        // if pointers events\n        currentTarget && currentTarget.setPointerCapture(pointerId);\n      } else {\n        _this.removeWindowListeners();\n\n        var dragListeners = [['mousemove', _this.onChange], ['mouseup', _this.onEnd], ['touchmove', _this.onChange], ['touchend', _this.onEnd], ['touchcancel', _this.onEnd]];\n\n        _this.addWindowListeners(dragListeners);\n      }\n\n      var startState = _this.getStartState(values, event);\n\n      _this.updateState(_extends({}, rest, {\n        dragging: true,\n        down: true\n      }), _extends({}, startState, {\n        currentTarget: currentTarget,\n        pointerId: pointerId,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      }), GestureFlag.OnStart);\n    };\n\n    _this.onChange = function (event) {\n      var _this$getState = _this.getState(),\n          canceled = _this$getState.canceled,\n          active = _this$getState.active;\n\n      if (canceled || !active) return;\n\n      var _getPointerEventData2 = getPointerEventData(event),\n          values = _getPointerEventData2.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, [\"values\"]);\n\n      if (rest.buttons === 0 && rest.touches === 0) {\n        _this.onEnd(event);\n\n        return;\n      }\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var cancel = function cancel() {\n        return _this.onCancel(event);\n      };\n\n      _this.updateState(rest, _extends({}, kinematics, {\n        first: false,\n        cancel: cancel\n      }), GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      var state = _this.getState();\n\n      if (!state.active) return;\n      var currentTarget = state.currentTarget,\n          pointerId = state.pointerId;\n      if (currentTarget && _this.pointerEventsEnabled()) currentTarget.releasePointerCapture(pointerId);else _this.removeWindowListeners();\n\n      _this.updateState({\n        dragging: false,\n        down: false,\n        buttons: 0,\n        touches: 0\n      }, _extends({}, genericEndState, {\n        event: event\n      }), GestureFlag.OnEnd);\n    };\n\n    _this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]];\n    }\n\n    return [[['onMouseDown', 'onTouchStart'], this.onStart]];\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\nvar ScrollRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getScrollEventData = getScrollEventData(event),\n          values = _getScrollEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getScrollEventData, [\"values\"]);\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState(values, event);\n\n        _this.updateState(_extends({\n          scrolling: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        scrolling: false\n      }, _extends({}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      }), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onScroll', this.onChange]];\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\nvar WheelRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getWheelEventData = getWheelEventData(event),\n          eventValues = _getWheelEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getWheelEventData, [\"values\"]);\n\n      var values = addV(eventValues, _this.getState().values);\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState(values, event);\n\n        _this.updateState(_extends({\n          wheeling: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        wheeling: false\n      }, _extends({}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      }), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onChange]];\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\nvar MoveRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getPointerEventData = getPointerEventData(event),\n          values = _getPointerEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData, [\"values\"]);\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState(values, event);\n\n        _this.updateState(_extends({\n          moving: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        moving: false\n      }, _extends({}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      }), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerMove', this.onChange]];\n    }\n\n    return [['onMouseMove', this.onChange]];\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\nvar HoverRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(HoverRecognizer, _CoordinatesRecognize);\n\n  function HoverRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'hover', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled()) return;\n\n      var _getPointerEventData = getPointerEventData(event),\n          values = _getPointerEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData, [\"values\"]);\n\n      _this.updateState(_extends({\n        hovering: true\n      }, rest), {\n        values: values,\n        event: event,\n        args: _this.args\n      }, GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      if (!_this.isEnabled()) return;\n\n      var _getPointerEventData2 = getPointerEventData(event),\n          values = _getPointerEventData2.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, [\"values\"]);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateState(_extends({\n        hovering: false,\n        moving: false\n      }, rest), _extends({}, kinematics, {}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      })); // when the mouse leaves the element, we also fire the move handler\n      // without waiting for move to end with debounce\n\n\n      _this.controller.fireGestureHandler('move', GestureFlag.OnEnd);\n\n      _this.controller.fireGestureHandler('hover', GestureFlag.OnChange);\n    };\n\n    return _this;\n  }\n\n  var _proto = HoverRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]];\n    }\n\n    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]];\n  };\n\n  return HoverRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\n\nvar DistanceAngleRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    var _this;\n\n    _this = _Recognizer.apply(this, arguments) || this;\n    /**\r\n     * Utility function to get kinematics of the gesture\r\n     * @d distance\r\n     * @a angle\r\n     * @event\r\n     * @returns set of values including delta, velocities, turns\r\n     */\n\n    _this.getKinematics = function (_ref, event) {\n      var d = _ref[0],\n          a = _ref[1];\n\n      var state = _this.getState();\n\n      var da = state.values,\n          turns = state.turns,\n          initial = state.initial,\n          lastLocal = state.lastLocal,\n          _state$time = state.time,\n          time = _state$time === void 0 ? 0 : _state$time; // angle might not be defined when ctrl wheel is used for zoom only\n      // in that case we set it to the previous angle value\n\n      a = a === undefined ? da[1] : a;\n      var diff_d = d - da[0];\n      var diff_a = a - da[1];\n      /**\r\n       * The angle value might jump from 179deg to -179deg when we actually want to\r\n       * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n       * is supsiciously high (ie > 300deg) and increase the `turns` value\r\n       */\n\n      var newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns; // we update the angle difference to its corrected value\n\n      diff_a -= 360 * newTurns;\n      var delta_d = d - initial[0];\n      var delta_a = a - 360 * newTurns - initial[1];\n      var delta = [delta_d, delta_a];\n      var delta_t = event.timeStamp - time;\n      var velocities = calculateVelocities([diff_d, diff_a], delta_t);\n      return {\n        event: event,\n        values: [d, a],\n        delta: delta,\n        velocities: velocities,\n        turns: newTurns,\n        local: addV(lastLocal, delta),\n        previous: da,\n        time: event.timeStamp\n      };\n    };\n\n    return _this;\n  }\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled() || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin,\n          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, [\"values\", \"origin\"]);\n\n      var startState = _this.getStartState(values, event);\n\n      _this.updateState(_extends({}, rest, {\n        pinching: true,\n        down: true\n      }), _extends({}, startState, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      }), GestureFlag.OnStart);\n    };\n\n    _this.onChange = function (event) {\n      var _this$getState = _this.getState(),\n          canceled = _this$getState.canceled,\n          active = _this$getState.active;\n\n      if (canceled || !active || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin,\n          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa2, [\"values\", \"origin\"]);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var cancel = function cancel() {\n        return _this.onCancel(event);\n      };\n\n      _this.updateState(rest, _extends({}, kinematics, {\n        origin: origin,\n        first: false,\n        cancel: cancel\n      }), GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        pinching: false,\n        down: false,\n        touches: 0\n      }, _extends({}, genericEndState, {\n        event: event\n      }), GestureFlag.OnEnd);\n    };\n\n    _this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\nvar PinchWheelRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWheelRecognizer, _DistanceAngleRecogni);\n\n  function PinchWheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled() || !event.ctrlKey) return;\n      event.preventDefault();\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getWheelEventData = getWheelEventData(event),\n          values = _getWheelEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getWheelEventData, [\"values\"]);\n\n      var d = _this.getState().values[0] - values[1];\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState([d, 0], event);\n\n        _this.updateState(_extends({\n          pinching: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics([d, undefined], event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        pinching: false,\n        down: false,\n        touches: 0\n      }, _extends({}, genericEndState), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchWheelRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onChange]];\n  };\n\n  return PinchWheelRecognizer;\n}(DistanceAngleRecognizer);\n\nvar SCALE_FACTOR = 260;\n\nvar PinchWebKitGestureRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWebKitGestureRecognizer, _DistanceAngleRecogni);\n\n  function PinchWebKitGestureRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled()) return;\n      event.preventDefault();\n      var da = [event.scale * SCALE_FACTOR, event.rotation];\n\n      var startState = _this.getStartState(da, event);\n\n      _this.updateState({\n        pinching: true,\n        down: true,\n        touches: 2\n      }, _extends({}, startState, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      }), GestureFlag.OnStart);\n    };\n\n    _this.onChange = function (event) {\n      var _this$getState = _this.getState(),\n          canceled = _this$getState.canceled,\n          active = _this$getState.active;\n\n      if (canceled || !active) return;\n      event.preventDefault();\n      var da = [event.scale * SCALE_FACTOR, event.rotation];\n\n      var kinematics = _this.getKinematics(da, event);\n\n      var cancel = function cancel() {\n        return _this.onCancel(event);\n      };\n\n      _this.updateState(null, _extends({}, kinematics, {\n        first: false,\n        cancel: cancel\n      }), GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      if (!_this.getState().active) return;\n      event.preventDefault();\n\n      _this.updateState({\n        pinching: false,\n        down: false,\n        touches: 0\n      }, _extends({}, genericEndState, {\n        event: event\n      }), GestureFlag.OnEnd);\n    };\n\n    _this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    };\n\n    _this.updateTouchData = function (event) {\n      if (!_this.isEnabled() || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateState(null, {\n        origin: origin\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchWebKitGestureRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onGestureStart', this.onStart], ['onGestureChange', this.onChange], [['onGestureEnd', 'onTouchCancel'], this.onEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];\n  };\n\n  return PinchWebKitGestureRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\r\n * and keep track of the state for all gestures\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\n\nvar GestureController = function GestureController(handlers, config) {\n  var _this = this;\n\n  this.handlers = handlers;\n  this.config = config;\n  this.state = initialState; // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  /**\r\n   * Function run on component unmount\r\n   * Cleans timeouts and removes dom listeners set by the bind function\r\n   */\n\n  this.clean = function () {\n    _this.cleanOnBind();\n\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render)\r\n   * Reset the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n\n  this.cleanOnBind = function () {\n    _this.bindings = {};\n    var domTarget = _this.config.domTarget;\n\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.event);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Commodity function to let gesture recognizer update global state\r\n   * @param sharedState shared partial state object\r\n   * @param gestureState partial gesture specific state object\r\n   * @param gestureKey the gesture key ('drag', 'move'...)\r\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\r\n   */\n\n\n  this.updateState = function (sharedState, gestureState, gestureKey, gestureFlag) {\n    var _extends2;\n\n    var stateKey = mappedKeys[gestureKey].stateKey;\n    _this.state = _extends({}, _this.state, (_extends2 = {\n      shared: _extends({}, _this.state.shared, {}, sharedState)\n    }, _extends2[stateKey] = _extends({}, _this.state[stateKey], {}, gestureState), _extends2));\n\n    if (gestureFlag) {\n      _this.fireGestureHandler(gestureKey, gestureFlag);\n    }\n  }; // fire the gesture handler defined by the user\n\n\n  this.fireGestureHandler = function (gestureKey, gestureFlag) {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    var _mappedKeys$gestureKe = mappedKeys[gestureKey],\n        stateKey = _mappedKeys$gestureKe.stateKey,\n        handlerKey = _mappedKeys$gestureKe.handlerKey;\n\n    var state = _extends({}, _this.state.shared, {}, _this.state[stateKey]);\n\n    if (gestureKey === 'pinch') {\n      var pinchState = state;\n      pinchState.da = state.values; // legacy state attribute for pinch gestures\n\n      pinchState.vdva = state.velocities; // legacy state attribute for pinch gestures\n    } else {\n      var coordinatesState = state;\n      coordinatesState.xy = state.values; // legacy state attribute for xy gestures\n\n      coordinatesState.vxvy = state.velocities; // legacy state attribute for xy gestures\n    } // TODO to be removed in future versions\n\n\n    state.temp = state.memo; // legacy temp attribute\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      var handlerStart = handlerKey + \"Start\";\n      var _handler = _this.handlers[handlerStart];\n      _handler && _handler(state);\n    } // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n\n\n    var handler = _this.handlers[handlerKey];\n\n    if (handler) {\n      var newMemo = handler(state);\n      _this.state[stateKey].memo = newMemo !== undefined ? newMemo : _this.state[stateKey].memo;\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      var handlerEnd = handlerKey + \"End\";\n      var _handler2 = _this.handlers[handlerEnd];\n      _handler2 && _handler2(state);\n    }\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window\r\n   * @param stateKey\r\n   * @param listeners\r\n   */\n\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.event);\n  }; // commodity function to let recognizers simply remove listeners from config.window\n\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.event);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * Adds a recognizer to this.bindings\r\n   * @param recognizer\r\n   */\n\n\n  this.addRecognizer = function (recognizer) {\n    recognizer.getEventBindings().map(_this.addEventBindings);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n\n  this.addEventBindings = function (_ref) {\n    var eventNames = _ref[0],\n        fn = _ref[1];\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      _this.bindings[eventName] = _this.bindings[eventName] ? [].concat(_this.bindings[eventName], [fn]) : [fn];\n    });\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n\n  this.addDomTargetListeners = function () {\n    var domTarget = _this.config.domTarget; // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n          fns = _ref2[1];\n\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(domTarget, _this.domListeners, _this.config.event);\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with\r\n   */\n\n\n  this.getBindings = function () {\n    var output = {};\n    var captureString = _this.config.event.capture ? 'Capture' : '';\n    Object.entries(_this.bindings).forEach(function (_ref3) {\n      var event = _ref3[0],\n          fns = _ref3[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      output[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return output;\n  };\n\n  this.bind = function () {\n    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n    // actions will skip on[Gesture][\"Start\"|\"End\"] functions and include\n    // ['onDrag', 'onMove']\n    var actions = new Set(Object.keys(_this.handlers).filter(function (k) {\n      return k.indexOf('on') === 0;\n    }).map(function (k) {\n      var match = k.match(/(on[A-Z][a-z]+)/);\n      return match ? match[1] : undefined;\n    }));\n    var domTarget = _this.config.domTarget;\n\n    var genuineHandlers = _extends({}, _this.handlers); // cleaning before adding\n\n\n    _this.cleanOnBind();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (actions.has('onDrag')) {\n      _this.addRecognizer(new DragRecognizer(_this, args));\n\n      delete genuineHandlers.onDrag;\n      delete genuineHandlers.onDragStart;\n      delete genuineHandlers.onDragEnd;\n    }\n\n    if (actions.has('onScroll')) {\n      _this.addRecognizer(new ScrollRecognizer(_this, args));\n\n      delete genuineHandlers.onScroll;\n      delete genuineHandlers.onScrollStart;\n      delete genuineHandlers.onScrollEnd;\n    }\n\n    if (actions.has('onWheel')) {\n      _this.addRecognizer(new WheelRecognizer(_this, args));\n\n      delete genuineHandlers.onWheel;\n      delete genuineHandlers.onWheelStart;\n      delete genuineHandlers.onWheelEnd;\n    }\n\n    if (actions.has('onMove')) {\n      _this.addRecognizer(new MoveRecognizer(_this, args));\n\n      delete genuineHandlers.onMove;\n      delete genuineHandlers.onMoveStart;\n      delete genuineHandlers.onMoveEnd;\n    }\n\n    if (actions.has('onHover')) {\n      _this.addRecognizer(new HoverRecognizer(_this, args));\n\n      delete genuineHandlers.onHover;\n    }\n\n    if (actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && supportsGestureEvent()) {\n        _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));\n      } else {\n        _this.addRecognizer(new PinchRecognizer(_this, args));\n\n        _this.addRecognizer(new PinchWheelRecognizer(_this, args));\n      }\n\n      delete genuineHandlers.onPinch;\n      delete genuineHandlers.onPinchStart;\n      delete genuineHandlers.onPinchEnd;\n    } // we also add event bindings for genuine handlers\n\n\n    Object.entries(genuineHandlers).map(function (_ref4) {\n      var event = _ref4[0],\n          fn = _ref4[1]; // we're cheating when it comes to event type :(\n\n      _this.addEventBindings([event, fn]);\n    }); // if config.domTarget is set we add event listeners to it and return the clean function\n\n    if (domTarget) {\n      _this.addDomTargetListeners();\n\n      return _this.clean;\n    } // if not, we return an object that contains gesture handlers mapped to react handler event keys\n\n\n    return _this.getBindings();\n  };\n};\n\nfunction useGesture(handlers, config) {\n  // the gesture controller will keep track of all gesture states\n  var gestureController = React.useRef();\n\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(getDerivedHandlers(handlers), getDerivedConfig(config));\n  }\n\n  React.useEffect(function () {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current.config = getDerivedConfig(config);\n    gestureController.current.handlers = getDerivedHandlers(handlers);\n  }, [handlers, config]); // when the user component unmounts, we run our gesture controller clean function\n\n  React.useEffect(function () {\n    return gestureController.current.clean;\n  }, []); // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n\n  return gestureController.current.bind;\n}\n/* SHORTHAND HANDLERS */\n\n\nvar useDrag = function useDrag(handler, config) {\n  return useGesture({\n    onDrag: handler\n  }, config);\n};\n\nvar useMove = function useMove(handler, config) {\n  return useGesture({\n    onMove: handler\n  }, config);\n};\n\nvar useHover = function useHover(handler, config) {\n  return useGesture({\n    onHover: handler\n  }, config);\n};\n\nvar useScroll = function useScroll(handler, config) {\n  return useGesture({\n    onScroll: handler\n  }, config);\n};\n\nvar useWheel = function useWheel(handler, config) {\n  return useGesture({\n    onWheel: handler\n  }, config);\n};\n\nvar usePinch = function usePinch(handler, config) {\n  return useGesture({\n    onPinch: handler\n  }, config);\n};\n\nfunction getDerivedHandlers(handlers) {\n  if (typeof handlers === 'function') return {\n    onDrag: handlers\n  };\n\n  var onAction = handlers.onAction,\n      rest = _objectWithoutPropertiesLoose(handlers, [\"onAction\"]);\n\n  var derivedHandlers = rest;\n  if (onAction) derivedHandlers.onDrag = onAction;\n  return derivedHandlers;\n}\n\nfunction getDerivedConfig(config) {\n  var derivedConfig = _extends({}, defaultConfig, {}, config);\n\n  var domTarget = derivedConfig.domTarget;\n  var realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  derivedConfig.domTarget = realDomTarget;\n  return derivedConfig;\n}\n\nexport { useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"sources":["../src/types.ts","../src/utils.ts","../src/defaults.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/recognizers/ScrollRecognizer.ts","../src/recognizers/WheelRecognizer.ts","../src/recognizers/MoveRecognizer.ts","../src/recognizers/HoverRecognizer.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/recognizers/PinchWheelRecognizer.ts","../src/recognizers/PinchWebKitGestureRecognizer.ts","../src/controllers/GestureController.ts","../src/index.ts"],"names":["GestureFlag","noop","chainFns","fns","args","fn","addV","v","v2","subV","setListeners","action","add","listeners","type","el","addListeners","removeListeners","getModifierKeys","event","shiftKey","altKey","metaKey","ctrlKey","getScrollEventData","scrollX","scrollY","scrollLeft","scrollTop","currentTarget","values","getWheelEventData","deltaX","deltaY","getPointerEventData","touches","buttons","changedTouches","touchEvents","clientX","clientY","down","getTwoTouchesEventData","dx","dy","da","Math","origin","calculateVelocity","diff","delta_t","len","calculateVelocities","Array","calculateDistance","delta","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","supportsGestureEvent","mappedKeys","drag","stateKey","handlerKey","pinch","move","scroll","wheel","hover","defaultConfig","domTarget","passive","capture","pointerEvents","window","transform","x","y","enabled","initialCommon","pointerId","initial","previous","local","lastLocal","first","last","active","time","cancel","canceled","memo","undefined","initialCoordinates","xy","vxvy","initialDistanceAngle","vdva","turns","initialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","genericEndState","Recognizer","ms","clearTimeout","state","CoordinatesRecognizer","Object","timeStamp","DragRecognizer","rest","dragListeners","startState","kinematics","requestAnimationFrame","getEventBindings","ScrollRecognizer","WheelRecognizer","eventValues","MoveRecognizer","HoverRecognizer","DistanceAngleRecognizer","d","a","diff_d","diff_a","newTurns","delta_d","delta_a","PinchRecognizer","PinchWheelRecognizer","SCALE_FACTOR","PinchWebKitGestureRecognizer","GestureController","config","gestureKey","pinchState","coordinatesState","gestureFlag","handlerStart","handler","newMemo","handlerEnd","recognizer","eventNames","eventNamesArray","output","captureString","fnsArray","key","actions","k","match","genuineHandlers","useGesture","handlers","gestureController","React","getDerivedHandlers","getDerivedConfig","useDrag","onDrag","useMove","onMove","useHover","onHover","useScroll","onScroll","useWheel","onWheel","usePinch","onPinch","onAction","derivedHandlers","derivedConfig","realDomTarget"],"mappings":"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","sourcesContent":["import React from 'react'\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\nexport type AtLeastOneOf<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U]\n\nexport type Vector2 = [number, number]\nexport type Fn = (...args: any[]) => any\nexport type TransformType = { x(x: number): number; y(y: number): number }\n\nexport type EventOptions = { capture: boolean; passive: boolean }\n\nexport interface GestureConfig {\n  domTarget?: EventTarget | React.RefObject<EventTarget> | null\n  event: EventOptions\n  window?: EventTarget | null\n  pointerEvents: boolean\n  transform: TransformType\n  enabled: boolean\n  drag: boolean\n  pinch: boolean\n  scroll: boolean\n  wheel: boolean\n  hover: boolean\n  move: boolean\n}\n\nexport enum GestureFlag {\n  OnStart = 'start',\n  OnChange = 'change',\n  OnEnd = 'end',\n}\n\nexport type GestureEvent = React.TouchEvent & { scale: number; rotation: number }\nexport type TransformedEvent<\n  T extends React.SyntheticEvent = React.MouseEvent | React.TouchEvent | React.WheelEvent | React.PointerEvent | GestureEvent\n> = T & {\n  transform?: TransformType\n}\n\nexport interface ReactEventHandlers {\n  // Mouse Events\n  onMouseDown?: React.MouseEventHandler\n  onMouseDownCapture?: React.MouseEventHandler\n  onMouseEnter?: React.MouseEventHandler\n  onMouseLeave?: React.MouseEventHandler\n  onMouseMove?: React.MouseEventHandler\n  onMouseMoveCapture?: React.MouseEventHandler\n  onMouseOut?: React.MouseEventHandler\n  onMouseOutCapture?: React.MouseEventHandler\n  onMouseOver?: React.MouseEventHandler\n  onMouseOverCapture?: React.MouseEventHandler\n  onMouseUp?: React.MouseEventHandler\n  onMouseUpCapture?: React.MouseEventHandler\n  // Touch Events\n  onTouchCancel?: React.TouchEventHandler\n  onTouchCancelCapture?: React.TouchEventHandler\n  onTouchEnd?: React.TouchEventHandler\n  onTouchEndCapture?: React.TouchEventHandler\n  onTouchMove?: React.TouchEventHandler\n  onTouchMoveCapture?: React.TouchEventHandler\n  onTouchStart?: React.TouchEventHandler\n  onTouchStartCapture?: React.TouchEventHandler\n\n  // Pointer Events\n  onPointerDown?: React.PointerEventHandler\n  onPointerDownCapture?: React.PointerEventHandler\n  onPointerMove?: React.PointerEventHandler\n  onPointerMoveCapture?: React.PointerEventHandler\n  onPointerUp?: React.PointerEventHandler\n  onPointerUpCapture?: React.PointerEventHandler\n  onPointerCancel?: React.PointerEventHandler\n  onPointerCancelCapture?: React.PointerEventHandler\n  onPointerEnter?: React.PointerEventHandler\n  onPointerEnterCapture?: React.PointerEventHandler\n  onPointerLeave?: React.PointerEventHandler\n  onPointerLeaveCapture?: React.PointerEventHandler\n  onPointerOver?: React.PointerEventHandler\n  onPointerOverCapture?: React.PointerEventHandler\n  onPointerOut?: React.PointerEventHandler\n  onPointerOutCapture?: React.PointerEventHandler\n  onGotPointerCapture?: React.PointerEventHandler\n  onGotPointerCaptureCapture?: React.PointerEventHandler\n  onLostPointerCapture?: React.PointerEventHandler\n  onLostPointerCaptureCapture?: React.PointerEventHandler\n\n  // UI Events\n  onScroll?: React.UIEventHandler\n  onScrollCapture?: React.UIEventHandler\n\n  // Wheel Events\n  onWheel?: React.WheelEventHandler\n  onWheelCapture?: React.WheelEventHandler\n\n  // Cheat mode for Gesture Events\n  onGestureStart?: Fn\n  onGestureChange?: Fn\n  onGestureEnd?: Fn\n}\n\nexport type ReactEventHandlerKey = keyof ReactEventHandlers\n\nexport type GestureKey = 'drag' | 'pinch' | 'move' | 'scroll' | 'wheel' | 'hover'\nexport type StateKey = Exclude<GestureKey, 'hover'>\n\nexport interface SharedGestureState {\n  hovering: boolean\n  scrolling: boolean\n  wheeling: boolean\n  dragging: boolean\n  moving: boolean\n  pinching: boolean\n  touches: number\n  down: boolean\n  buttons: number\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\nexport interface CommonGestureState {\n  event?: TransformedEvent\n  currentTarget?: EventTarget | null\n  pointerId?: number | null\n  values: Vector2\n  velocities: Vector2\n  delta: Vector2\n  initial: Vector2\n  previous: Vector2\n  transform?: TransformType\n  local: Vector2\n  lastLocal: Vector2\n  first: boolean\n  last: boolean\n  active: boolean\n  time?: number\n  cancel?(): void\n  canceled: boolean\n  memo?: any\n  temp?: any // TODO to be removed in future versions\n  args?: any\n}\n\nexport interface Coordinates {\n  xy: Vector2\n  velocity: number\n  vxvy: Vector2\n  distance: number\n  direction: Vector2\n}\n\nexport interface DistanceAngle {\n  da: Vector2\n  vdva: Vector2\n  origin: Vector2\n  turns: number\n}\n\nexport type GestureState<T extends Coordinates | DistanceAngle> = T & CommonGestureState\nexport type FullGestureState<T extends Coordinates | DistanceAngle> = SharedGestureState & GestureState<T>\n\nexport type StateObject = { shared: SharedGestureState } & { [K in StateKey]: GestureState<Coordinates | DistanceAngle> }\n\nexport type Handler<T extends Coordinates | DistanceAngle> = (state: FullGestureState<T>) => any | void\nexport type HandlerKey = 'onDrag' | 'onPinch' | 'onMove' | 'onHover' | 'onScroll' | 'onWheel'\n\nexport type GestureHandlers = {\n  onAction: Handler<Coordinates>\n  onDrag: Handler<Coordinates>\n  onDragStart: Handler<Coordinates>\n  onDragEnd: Handler<Coordinates>\n  onHover: Handler<Coordinates>\n  onMove: Handler<Coordinates>\n  onMoveStart: Handler<Coordinates>\n  onMoveEnd: Handler<Coordinates>\n  onScroll: Handler<Coordinates>\n  onScrollStart: Handler<Coordinates>\n  onScrollEnd: Handler<Coordinates>\n  onWheel: Handler<Coordinates>\n  onWheelStart: Handler<Coordinates>\n  onWheelEnd: Handler<Coordinates>\n  onPinch: Handler<DistanceAngle>\n  onPinchStart: Handler<DistanceAngle>\n  onPinchEnd: Handler<DistanceAngle>\n}\n\n/* Handlers should also accept DomAttributes to prevent overrides */\nexport type GestureHandlersPartial = AtLeastOneOf<GestureHandlers> &\n  Partial<Omit<React.DOMAttributes<Element>, 'onDrag' | 'onScroll' | 'onWheel'>>\n","import React from 'react'\nimport { Fn, Vector2, EventOptions, Coordinates, FullGestureState, DistanceAngle, TransformedEvent } from './types'\n\n// blank function\nexport const noop = () => {}\n\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\n// vector add\nexport const addV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v + v2[i])\n\n// vector substract\nexport const subV = <T extends number[]>(v1: T, v2: T): T => <T>v1.map((v, i) => v - v2[i])\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([type, fn]) => el[action](type, fn, options))\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: TransformedEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\ntype ScrollEventData = Pick<FullGestureState<Coordinates>, 'values'> & ModifierKeys\n\n/**\n * Gets scroll event data\n * @param event\n * @returns scroll event data\n */\nexport function getScrollEventData(event: TransformedEvent): ScrollEventData {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = <Element & Window>event.currentTarget\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0], ...getModifierKeys(event) }\n}\n\ntype WheelEventData = Pick<FullGestureState<Coordinates>, 'values'> & ModifierKeys\n\n/**\n * Gets wheel event data\n * @param event\n * @returns wheel event data\n */\nexport function getWheelEventData(event: TransformedEvent<React.WheelEvent>): WheelEventData {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY], ...getModifierKeys(event) }\n}\ntype PointerEventData = Pick<FullGestureState<Coordinates>, 'values' | 'touches' | 'down' | 'buttons'> & ModifierKeys\n\n/**\n * Gets pointer event data\n * @param event\n * @returns pointer event data\n */\nexport function getPointerEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): PointerEventData {\n  const { touches, buttons, changedTouches } = event as any\n  const touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : event\n  const down = (touchEvents && touchEvents.length > 0) || buttons > 0\n  return {\n    values: [clientX, clientY],\n    touches: (touchEvents && touchEvents.length) || 0,\n    down,\n    buttons,\n    ...getModifierKeys(event),\n  }\n}\n\ntype TwoTouchesEventData = Pick<FullGestureState<DistanceAngle>, 'values' | 'touches' | 'down' | 'origin'> & ModifierKeys\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent): TwoTouchesEventData {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const da: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values: da, origin, touches: 2, down: touches.length > 0, ...getModifierKeys(event) }\n}\n\n/**\n * Calculates velocity\n * @param diff the difference between current and previous vectors\n * @param delta_t the time delta\n * @param len the length of the diff vector\n * @returns velocity\n */\nexport function calculateVelocity(diff: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...diff)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param diff the previous value\n * @param delta_t the time delta\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(diff: T, delta_t: number): T {\n  return delta_t ? <T>diff.map(v => v / delta_t) : <T>Array(diff.length).fill(0)\n}\n\n/**\n * Calculates distance\n * @param delta the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(delta: number[]): number {\n  return Math.hypot(...delta)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param diff\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(diff: T, len: number): T {\n  len = len || Math.hypot(...diff) || 1\n  return <T>diff.map(v => v / len)\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param delta the difference between current and initial vectors\n * @param diff the difference between current and previous vectors\n * @param delta_t the time delta between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(delta: T, diff: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...diff)\n\n  return {\n    velocities: calculateVelocities(diff, delta_t),\n    velocity: calculateVelocity(diff, delta_t, len),\n    distance: calculateDistance(delta),\n    direction: calculateDirection(diff, len),\n  }\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvent(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n","import { noop } from './utils'\nimport { GestureConfig, HandlerKey, CommonGestureState, Coordinates, DistanceAngle, StateObject, StateKey, GestureKey } from './types'\n\ntype MappedKeys = { [K in GestureKey]: { stateKey: StateKey; handlerKey: HandlerKey } }\n\n/**\n * Some gestures might use the state key from another gesture (i.e. hover)\n * so mappedKeys is a commodity object to get the state key and handler key\n * for every gesture\n */\nexport const mappedKeys: MappedKeys = {\n  drag: { stateKey: 'drag', handlerKey: 'onDrag' },\n  pinch: { stateKey: 'pinch', handlerKey: 'onPinch' },\n  move: { stateKey: 'move', handlerKey: 'onMove' },\n  scroll: { stateKey: 'scroll', handlerKey: 'onScroll' },\n  wheel: { stateKey: 'wheel', handlerKey: 'onWheel' },\n  hover: { stateKey: 'move', handlerKey: 'onHover' },\n}\n\n// default config (will extend user config)\nexport const defaultConfig: GestureConfig = {\n  domTarget: undefined,\n  event: { passive: true, capture: false },\n  pointerEvents: false,\n  window: typeof window !== 'undefined' ? window : undefined,\n  transform: { x: (x: number): number => x, y: (y: number): number => y },\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true,\n}\n\n// common initial state for all gestures\nexport const initialCommon: CommonGestureState = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  velocities: [0, 0],\n  delta: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  transform: undefined,\n  local: [0, 0],\n  lastLocal: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined,\n}\n\n// initial state for coordinates-based gestures\nconst initialCoordinates: Coordinates = { xy: [0, 0], vxvy: [0, 0], velocity: 0, distance: 0, direction: [0, 0] } // xy coordinates\n\n// initial state for distance and angle-based gestures (pinch)\nconst initialDistanceAngle: DistanceAngle = { da: [0, 0], vdva: [0, 0], origin: [0, 0], turns: 0 } // distance and angle\n\n// initial state object (used by the gesture controller)\nexport const initialState: StateObject = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n  },\n  move: { ...initialCommon, ...initialCoordinates },\n  drag: { ...initialCommon, ...initialCoordinates },\n  scroll: { ...initialCommon, ...initialCoordinates },\n  wheel: { ...initialCommon, ...initialCoordinates },\n  pinch: { ...initialCommon, ...initialDistanceAngle },\n}\n\n// generic end state for all gestures\nexport const genericEndState = { first: false, last: true, active: false }\n","import { initialState, mappedKeys } from '../defaults'\nimport GestureController from '../controllers/GestureController'\nimport {\n  Coordinates,\n  DistanceAngle,\n  StateKey,\n  GestureState,\n  GestureKey,\n  SharedGestureState,\n  Fn,\n  Vector2,\n  TransformType,\n  ReactEventHandlerKey,\n  GestureFlag,\n  TransformedEvent,\n} from '../types'\n\n/**\n * Recognizer abstract class\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<GestureType extends Coordinates | DistanceAngle> {\n  protected stateKey: StateKey\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param gestureKey drag, move, hover, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly gestureKey: GestureKey,\n    protected readonly controller: GestureController,\n    protected readonly args: any[] = []\n  ) {\n    // mapping this.stateKey to the state key the gesture handles\n    // (ie hover actually deals with the move gesture state)\n    this.stateKey = mappedKeys[gestureKey].stateKey\n  }\n\n  protected isEnabled = (): boolean => {\n    return this.controller.config.enabled && this.controller.config[this.gestureKey]\n  }\n\n  // convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // get the controller state for a given gesture\n  protected getState = (): GestureState<GestureType> => this.controller.state[this.stateKey] as GestureState<GestureType>\n  // get the controller shared state\n  protected getSharedState = () => this.controller.state.shared\n  // does the controller config has pointer events enabled\n  protected pointerEventsEnabled = () => this.controller.config.pointerEvents\n  // gets the transform config of the controller\n  protected getTransformConfig = () => this.controller.config.transform\n\n  // convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  // should return the bindings for a given gesture\n  public abstract getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][]\n\n  /**\n   * convenience method to update the controller state for a given gesture\n   * @param sharedState shared partial state object\n   * @param gestureState partial state object for the gesture handled by the recognizer\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\n   */\n  protected updateState = (\n    sharedState: Partial<SharedGestureState> | null,\n    gestureState: Partial<GestureState<GestureType>>,\n    gestureFlag?: GestureFlag\n  ): void => {\n    this.controller.updateState(sharedState, gestureState, this.gestureKey, gestureFlag)\n  }\n\n  /**\n   * returns the start state for a given gesture\n   * @param values the values of the start state\n   * @param event the event that triggers the gesture start\n   */\n  protected getStartState = (values: Vector2, event: TransformedEvent): GestureState<GestureType> => {\n    const state = this.getState()\n    const initial = initialState[this.stateKey]\n    const transform: TransformType = state.transform || event.transform || this.getTransformConfig()\n    const lastLocal = state.local || initial.local\n\n    return <GestureState<GestureType>>{\n      ...(initial as object),\n      event,\n      values,\n      initial: values,\n      previous: values,\n      local: lastLocal,\n      lastLocal,\n      first: true,\n      active: true,\n      transform,\n      time: event.timeStamp,\n      args: this.args,\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, subV, calculateAllKinematics } from '../utils'\nimport { TransformedEvent, Vector2, TransformType, GestureState, Coordinates } from '../types'\n\n/**\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer extends Recognizer<Coordinates> {\n  /**\n   * Utility function to get kinematics of the gesture\n   * @values values we want to calculate the kinematics from\n   * @event\n   * @returns set of values including delta, velocity, velocities, distance and direction\n   */\n  protected getKinematics = (values: Vector2, event: TransformedEvent): Partial<GestureState<Coordinates>> => {\n    // we get the gesture specific state\n    const state = this.getState()\n    const { values: xy, initial, lastLocal, time = 0 } = state\n    const transform: TransformType = state.transform || event.transform || this.getTransformConfig()\n\n    // delta is the difference between the current and initial value vectors\n    const delta = subV(values, initial).map((v, i) => Object.values(transform)[i](v)) as Vector2\n    // diff is the difference between the current and previous value vectors\n    const diff = subV(values, xy).map((v, i) => Object.values(transform)[i](v)) as Vector2\n\n    const delta_t = event.timeStamp - time\n    const { velocity, velocities, distance, direction } = calculateAllKinematics(delta, diff, delta_t)\n\n    return {\n      event,\n      values,\n      delta,\n      velocity,\n      velocities,\n      distance,\n      direction,\n      local: addV(lastLocal, delta),\n      previous: xy,\n      transform,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { noop, getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class DragRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  onStart = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n\n    const { values, ...rest } = getPointerEventData(event)\n    // making sure we're not dragging the element when more than one finger press the screen\n    if (rest.touches > 1) return\n\n    const { currentTarget, pointerId } = event as PointerEvent\n    if (this.pointerEventsEnabled()) {\n      // if pointers events\n      currentTarget && (currentTarget as any).setPointerCapture(pointerId)\n    } else {\n      this.removeWindowListeners()\n      const dragListeners: [string, Fn][] = [\n        ['mousemove', this.onChange],\n        ['mouseup', this.onEnd],\n        ['touchmove', this.onChange],\n        ['touchend', this.onEnd],\n        ['touchcancel', this.onEnd],\n      ]\n      this.addWindowListeners(dragListeners)\n    }\n\n    const startState = this.getStartState(values, event)\n\n    this.updateState(\n      { ...rest, dragging: true, down: true },\n      { ...startState, currentTarget, pointerId, cancel: () => this.onCancel(event) },\n      GestureFlag.OnStart\n    )\n  }\n\n  onChange = (event: TransformedEvent): void => {\n    const { canceled, active } = this.getState()\n    if (canceled || !active) return\n\n    const { values, ...rest } = getPointerEventData(event)\n\n    if (rest.buttons === 0 && rest.touches === 0) {\n      this.onEnd(event)\n      return\n    }\n\n    const kinematics = this.getKinematics(values, event)\n    const cancel = () => this.onCancel(event)\n\n    this.updateState(rest, { ...kinematics, first: false, cancel }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent): void => {\n    const state = this.getState()\n    if (!state.active) return\n\n    const { currentTarget, pointerId } = state\n    if (currentTarget && this.pointerEventsEnabled()) (currentTarget as any).releasePointerCapture(pointerId)\n    else this.removeWindowListeners()\n\n    this.updateState({ dragging: false, down: false, buttons: 0, touches: 0 }, { ...genericEndState, event }, GestureFlag.OnEnd)\n  }\n\n  onCancel = (event: TransformedEvent): void => {\n    this.updateState(null, { canceled: true, cancel: noop })\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]]\n    }\n    return [[['onMouseDown', 'onTouchStart'], this.onStart]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getScrollEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  onChange = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values, ...rest } = getScrollEventData(event)\n\n    if (!this.getState().active) {\n      const startState = this.getStartState(values, event)\n      this.updateState({ scrolling: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics(values, event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ scrolling: false }, { ...genericEndState, velocity: 0, velocities: [0, 0] }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onScroll', this.onChange]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { addV, getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  onChange = (event: TransformedEvent<WheelEvent>): void => {\n    if (!this.isEnabled()) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values: eventValues, ...rest } = getWheelEventData(event)\n    const values = addV(eventValues, this.getState().values)\n\n    if (!this.getState().active) {\n      const startState = this.getStartState(values, event)\n      this.updateState({ wheeling: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics(values, event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ wheeling: false }, { ...genericEndState, velocity: 0, velocities: [0, 0] }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onChange]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('move', controller, args)\n  }\n\n  onChange = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values, ...rest } = getPointerEventData(event)\n\n    if (!this.getState().active) {\n      const startState = this.getStartState(values, event)\n      this.updateState({ moving: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics(values, event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ moving: false }, { ...genericEndState, velocity: 0, velocities: [0, 0] }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerMove', this.onChange]]\n    }\n    return [['onMouseMove', this.onChange]]\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { GestureFlag, TransformedEvent, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class HoverRecognizer extends CoordinatesRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('hover', controller, args)\n  }\n\n  onStart = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n    const { values, ...rest } = getPointerEventData(event)\n    this.updateState({ hovering: true, ...rest }, { values, event, args: this.args }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent): void => {\n    if (!this.isEnabled()) return\n    const { values, ...rest } = getPointerEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateState({ hovering: false, moving: false, ...rest }, { ...kinematics, ...genericEndState, velocity: 0, velocities: [0, 0] })\n\n    // when the mouse leaves the element, we also fire the move handler\n    // without waiting for move to end with debounce\n    this.controller.fireGestureHandler('move', GestureFlag.OnEnd)\n    this.controller.fireGestureHandler('hover', GestureFlag.OnChange)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]]\n    }\n    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]]\n  }\n}\n","import Recognizer from './Recognizer'\nimport { addV, calculateVelocities } from '../utils'\nimport { DistanceAngle, GestureState, Vector2, TransformedEvent } from '../types'\n\n/**\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer extends Recognizer<DistanceAngle> {\n  /**\n   * Utility function to get kinematics of the gesture\n   * @d distance\n   * @a angle\n   * @event\n   * @returns set of values including delta, velocities, turns\n   */\n  protected getKinematics = ([d, a]: [number, number?], event: TransformedEvent): Partial<GestureState<DistanceAngle>> => {\n    const state = this.getState()\n    const { values: da, turns, initial, lastLocal, time = 0 } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a === undefined ? da[1] : a\n\n    const diff_d = d - da[0]\n    let diff_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 300deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns\n\n    // we update the angle difference to its corrected value\n    diff_a -= 360 * newTurns\n    const delta_d = d - initial[0]\n    const delta_a = a - 360 * newTurns - initial[1]\n\n    const delta: Vector2 = [delta_d, delta_a]\n\n    const delta_t = event.timeStamp - time\n    const velocities = calculateVelocities([diff_d, diff_a], delta_t) as Vector2\n\n    return {\n      event,\n      values: [d, a],\n      delta,\n      velocities,\n      turns: newTurns,\n      local: addV(lastLocal, delta),\n      previous: da,\n      time: event.timeStamp,\n    }\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { noop, getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  onStart = (event: TransformedEvent<TouchEvent>): void => {\n    if (!this.isEnabled() || event.touches.length !== 2) return\n\n    const { values, origin, ...rest } = getTwoTouchesEventData(event)\n\n    const startState = this.getStartState(values, event)\n    this.updateState(\n      { ...rest, pinching: true, down: true },\n      { ...startState, origin, cancel: () => this.onCancel(event) },\n      GestureFlag.OnStart\n    )\n  }\n\n  onChange = (event: TransformedEvent<TouchEvent>): void => {\n    const { canceled, active } = this.getState()\n    if (canceled || !active || event.touches.length !== 2) return\n\n    const { values, origin, ...rest } = getTwoTouchesEventData(event)\n\n    const kinematics = this.getKinematics(values, event)\n    const cancel = () => this.onCancel(event)\n\n    this.updateState(rest, { ...kinematics, origin, first: false, cancel }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent<TouchEvent>): void => {\n    if (!this.getState().active) return\n    this.updateState({ pinching: false, down: false, touches: 0 }, { ...genericEndState, event }, GestureFlag.OnEnd)\n  }\n\n  onCancel = (event: TransformedEvent<TouchEvent>): void => {\n    this.updateState(null, { canceled: true, cancel: noop })\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]]\n  }\n}\n","import { WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { getWheelEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, Fn } from '../types'\nimport { genericEndState } from '../defaults'\n\nexport default class PinchWheelRecognizer extends DistanceAngleRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  onChange = (event: TransformedEvent<WheelEvent>): void => {\n    if (!this.isEnabled() || !event.ctrlKey) return\n    event.preventDefault()\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const { values, ...rest } = getWheelEventData(event)\n    const d = this.getState().values[0] - values[1]\n\n    if (!this.getState().active) {\n      const startState = this.getStartState([d, 0], event)\n      this.updateState({ pinching: true, ...rest }, startState, GestureFlag.OnStart)\n    } else {\n      const kinematics = this.getKinematics([d, undefined], event)\n      this.updateState(rest, { ...kinematics, first: false }, GestureFlag.OnChange)\n    }\n  }\n\n  onEnd = (): void => {\n    if (!this.getState().active) return\n    this.updateState({ pinching: false, down: false, touches: 0 }, { ...genericEndState }, GestureFlag.OnEnd)\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [['onWheel', this.onChange]]\n  }\n}\n","import { TouchEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { noop, getTwoTouchesEventData } from '../utils'\nimport GestureController from '../controllers/GestureController'\nimport { TransformedEvent, GestureFlag, ReactEventHandlerKey, GestureEvent, Fn, Vector2 } from '../types'\nimport { genericEndState } from '../defaults'\n\nconst SCALE_FACTOR = 260\n\nexport default class PinchWebKitGestureRecognizer extends DistanceAngleRecognizer {\n  constructor(controller: GestureController, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  onStart = (event: TransformedEvent<GestureEvent>): void => {\n    if (!this.isEnabled()) return\n    event.preventDefault()\n\n    const da: Vector2 = [event.scale * SCALE_FACTOR, event.rotation]\n\n    const startState = this.getStartState(da, event)\n    this.updateState({ pinching: true, down: true, touches: 2 }, { ...startState, cancel: () => this.onCancel(event) }, GestureFlag.OnStart)\n  }\n\n  onChange = (event: TransformedEvent<GestureEvent>): void => {\n    const { canceled, active } = this.getState()\n    if (canceled || !active) return\n    event.preventDefault()\n\n    const da: Vector2 = [event.scale * SCALE_FACTOR, event.rotation]\n\n    const kinematics = this.getKinematics(da, event)\n    const cancel = () => this.onCancel(event)\n\n    this.updateState(null, { ...kinematics, first: false, cancel }, GestureFlag.OnChange)\n  }\n\n  onEnd = (event: TransformedEvent): void => {\n    if (!this.getState().active) return\n    event.preventDefault()\n    this.updateState({ pinching: false, down: false, touches: 0 }, { ...genericEndState, event }, GestureFlag.OnEnd)\n  }\n\n  onCancel = (event: TransformedEvent): void => {\n    this.updateState(null, { canceled: true, cancel: noop })\n    requestAnimationFrame(() => this.onEnd(event))\n  }\n\n  updateTouchData = (event: TransformedEvent<TouchEvent>): void => {\n    if (!this.isEnabled() || event.touches.length !== 2) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.updateState(null, { origin })\n  }\n\n  getEventBindings(): [ReactEventHandlerKey | ReactEventHandlerKey[], Fn][] {\n    return [\n      ['onGestureStart', this.onStart],\n      ['onGestureChange', this.onChange],\n      [['onGestureEnd', 'onTouchCancel'], this.onEnd],\n      [['onTouchStart', 'onTouchMove'], this.updateTouchData],\n    ]\n  }\n}\n","import {\n  Coordinates,\n  DistanceAngle,\n  StateKey,\n  StateObject,\n  GestureState,\n  SharedGestureState,\n  GestureKey,\n  FullGestureState,\n  Fn,\n  ReactEventHandlerKey,\n  GestureFlag,\n  ReactEventHandlers,\n  GestureConfig,\n  GestureHandlers,\n  HandlerKey,\n  GestureHandlersPartial,\n} from '../types'\n\nimport { initialState, mappedKeys } from '../defaults'\nimport { addListeners, removeListeners, supportsGestureEvent, chainFns } from '../utils'\n\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport HoverRecognizer from '../recognizers/HoverRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport PinchWheelRecognizer from '../recognizers/PinchWheelRecognizer'\nimport PinchWebKitGestureRecognizer from '../recognizers/PinchWebKitGestureRecognizer'\nimport CoordinatesRecognizer from '../recognizers/CoordinatesRecognizer'\nimport DistanceAngleRecognizer from '../recognizers/DistanceAngleRecognizer'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] | Fn }>\n\n/**\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\n * and keep track of the state for all gestures\n *\n * @template BinderType the type the bind function should return\n */\nexport default class GestureController {\n  public state: StateObject = initialState // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n\n  constructor(public handlers: GestureHandlersPartial, public config: GestureConfig) {}\n\n  /**\n   * Function run on component unmount\n   * Cleans timeouts and removes dom listeners set by the bind function\n   */\n  public clean = (): void => {\n    this.cleanOnBind()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(<StateKey>stateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render)\n   * Reset the binding object and remove dom listeners attached to config.domTarget\n   */\n  private cleanOnBind = (): void => {\n    this.bindings = {}\n    const { domTarget } = this.config\n    if (domTarget) {\n      removeListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Commodity function to let gesture recognizer update global state\n   * @param sharedState shared partial state object\n   * @param gestureState partial gesture specific state object\n   * @param gestureKey the gesture key ('drag', 'move'...)\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\n   */\n  public updateState = (\n    sharedState: Partial<SharedGestureState> | null,\n    gestureState: Partial<GestureState<Coordinates | DistanceAngle>>,\n    gestureKey: GestureKey,\n    gestureFlag?: GestureFlag\n  ): void => {\n    const stateKey = mappedKeys[gestureKey].stateKey\n\n    this.state = {\n      ...this.state,\n      shared: { ...this.state.shared, ...sharedState },\n      [stateKey]: { ...this.state[stateKey], ...(gestureState as object) },\n    }\n\n    if (gestureFlag) {\n      this.fireGestureHandler(gestureKey, gestureFlag)\n    }\n  }\n\n  // fire the gesture handler defined by the user\n  public fireGestureHandler = (gestureKey: GestureKey, gestureFlag: GestureFlag): void => {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    const { stateKey, handlerKey } = mappedKeys[gestureKey]\n    const state = { ...this.state.shared, ...this.state[stateKey] }\n\n    if (gestureKey === 'pinch') {\n      const pinchState = state as FullGestureState<DistanceAngle>\n      pinchState.da = state.values // legacy state attribute for pinch gestures\n      pinchState.vdva = state.velocities // legacy state attribute for pinch gestures\n    } else {\n      const coordinatesState = state as FullGestureState<Coordinates>\n      coordinatesState.xy = state.values // legacy state attribute for xy gestures\n      coordinatesState.vxvy = state.velocities // legacy state attribute for xy gestures\n    }\n    // TODO to be removed in future versions\n    state.temp = state.memo // legacy temp attribute\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      const handlerStart = `${handlerKey}Start` as keyof GestureHandlers\n      const handler = this.handlers[handlerStart] as any\n      handler && handler(state)\n    }\n\n    // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n    const handler = this.handlers[handlerKey] as any\n    if (handler) {\n      const newMemo = handler(state)\n      this.state[stateKey].memo = newMemo !== undefined ? newMemo : this.state[stateKey].memo\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      const handlerEnd = `${handlerKey}End` as keyof GestureHandlers\n      const handler = this.handlers[handlerEnd] as any\n      handler && handler(state)\n    }\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window\n   * @param stateKey\n   * @param listeners\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.event)\n  }\n\n  // commodity function to let recognizers simply remove listeners from config.window\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.event)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * Adds a recognizer to this.bindings\n   * @param recognizer\n   */\n  private addRecognizer = (recognizer: CoordinatesRecognizer | DistanceAngleRecognizer): void => {\n    recognizer.getEventBindings().map(this.addEventBindings)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  private addEventBindings = ([eventNames, fn]: [ReactEventHandlerKey | ReactEventHandlerKey[], Fn]): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n\n    eventNamesArray.forEach(eventName => {\n      this.bindings[eventName] = this.bindings[eventName] ? [...(<Fn[]>this.bindings[eventName]), fn] : [fn]\n    })\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  private addDomTargetListeners = (): void => {\n    const { domTarget } = this.config\n\n    // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(<Fn[]>fns))])\n    })\n\n    addListeners(<EventTarget>domTarget, this.domListeners, this.config.event)\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with\n   */\n  private getBindings = (): ReactEventHandlers => {\n    const output: ReactEventHandlers = {}\n    const captureString = this.config.event.capture ? 'Capture' : ''\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      output[key] = chainFns(...(<Fn[]>fnsArray))\n    })\n\n    return output\n  }\n\n  public bind = (...args: any[]): Fn | ReactEventHandlers => {\n    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n    // actions will skip on[Gesture][\"Start\"|\"End\"] functions and include\n    // ['onDrag', 'onMove']\n    const actions: Set<HandlerKey | undefined> = new Set(\n      Object.keys(this.handlers)\n        .filter(k => k.indexOf('on') === 0)\n        .map(k => {\n          const match = k.match(/(on[A-Z][a-z]+)/)\n          return match ? <HandlerKey>match[1] : undefined\n        })\n    )\n\n    const { domTarget } = this.config\n\n    const genuineHandlers = { ...this.handlers }\n\n    // cleaning before adding\n    this.cleanOnBind()\n\n    if (actions.has('onDrag')) {\n      this.addRecognizer(new DragRecognizer(this, args))\n      delete genuineHandlers.onDrag\n      delete genuineHandlers.onDragStart\n      delete genuineHandlers.onDragEnd\n    }\n    if (actions.has('onScroll')) {\n      this.addRecognizer(new ScrollRecognizer(this, args))\n      delete genuineHandlers.onScroll\n      delete genuineHandlers.onScrollStart\n      delete genuineHandlers.onScrollEnd\n    }\n    if (actions.has('onWheel')) {\n      this.addRecognizer(new WheelRecognizer(this, args))\n      delete genuineHandlers.onWheel\n      delete genuineHandlers.onWheelStart\n      delete genuineHandlers.onWheelEnd\n    }\n    if (actions.has('onMove')) {\n      this.addRecognizer(new MoveRecognizer(this, args))\n      delete genuineHandlers.onMove\n      delete genuineHandlers.onMoveStart\n      delete genuineHandlers.onMoveEnd\n    }\n    if (actions.has('onHover')) {\n      this.addRecognizer(new HoverRecognizer(this, args))\n      delete genuineHandlers.onHover\n    }\n    if (actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && supportsGestureEvent()) {\n        this.addRecognizer(new PinchWebKitGestureRecognizer(this, args))\n      } else {\n        this.addRecognizer(new PinchRecognizer(this, args))\n        this.addRecognizer(new PinchWheelRecognizer(this, args))\n      }\n      delete genuineHandlers.onPinch\n      delete genuineHandlers.onPinchStart\n      delete genuineHandlers.onPinchEnd\n    }\n\n    // we also add event bindings for genuine handlers\n    Object.entries(genuineHandlers).map(([event, fn]) => {\n      // we're cheating when it comes to event type :(\n      this.addEventBindings([<ReactEventHandlerKey>event, <Fn>fn])\n    })\n\n    // if config.domTarget is set we add event listeners to it and return the clean function\n    if (domTarget) {\n      this.addDomTargetListeners()\n      return this.clean\n    }\n\n    // if not, we return an object that contains gesture handlers mapped to react handler event keys\n    return this.getBindings()\n  }\n}\n","import React from 'react'\nimport GestureController from './controllers/GestureController'\nimport { Handler, GestureHandlersPartial, GestureConfig, Coordinates, Fn, ReactEventHandlers, DistanceAngle } from './types'\nimport { defaultConfig } from './defaults'\n\n/** API\n * Default Drag:\n * const bind = useGesture(() => { ... })\n *\n * Handlers object:\n * const bind = useGesture({ onDrag: () => { ... }, onMove: () => { ... } })\n *\n * DomTarget:\n * const bind = useGesture({ onScroll: () => { ... } }, { domTarget: window })\n * React.useEffect(bind, [bind])\n */\n\ntype GetBinderTypeFromDomTarget<T extends Partial<GestureConfig>> = T['domTarget'] extends object ? Fn : ReactEventHandlers\n\nexport function useGesture<Config extends Partial<GestureConfig>>(\n  handlers: GestureHandlersPartial | Handler<Coordinates>,\n  config?: Config\n): (...args: any[]) => GetBinderTypeFromDomTarget<Config> {\n  // the gesture controller will keep track of all gesture states\n  const gestureController = React.useRef<GestureController>()\n\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(getDerivedHandlers(handlers), getDerivedConfig(config))\n  }\n\n  React.useEffect(() => {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current!.config = getDerivedConfig(config)\n    gestureController.current!.handlers = getDerivedHandlers(handlers)\n  }, [handlers, config])\n\n  // when the user component unmounts, we run our gesture controller clean function\n  React.useEffect(() => gestureController.current!.clean, [])\n\n  // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n  return gestureController.current.bind as (...args: any[]) => GetBinderTypeFromDomTarget<Config>\n}\n\n/* SHORTHAND HANDLERS */\nexport const useDrag = (handler: Handler<Coordinates>, config?: Partial<GestureConfig>) => useGesture({ onDrag: handler }, config)\nexport const useMove = (handler: Handler<Coordinates>, config?: Partial<GestureConfig>) => useGesture({ onMove: handler }, config)\nexport const useHover = (handler: Handler<Coordinates>, config?: Partial<GestureConfig>) => useGesture({ onHover: handler }, config)\nexport const useScroll = (handler: Handler<Coordinates>, config?: Partial<GestureConfig>) => useGesture({ onScroll: handler }, config)\nexport const useWheel = (handler: Handler<Coordinates>, config?: Partial<GestureConfig>) => useGesture({ onWheel: handler }, config)\nexport const usePinch = (handler: Handler<DistanceAngle>, config?: Partial<GestureConfig>) => useGesture({ onPinch: handler }, config)\n\nfunction getDerivedHandlers(handlers: GestureHandlersPartial | Handler<Coordinates>): GestureHandlersPartial {\n  if (typeof handlers === 'function') return { onDrag: handlers }\n\n  const { onAction, ...rest } = handlers\n  const derivedHandlers = rest as GestureHandlersPartial\n\n  if (onAction) derivedHandlers.onDrag = onAction\n\n  return derivedHandlers\n}\n\nfunction getDerivedConfig(config?: Partial<GestureConfig>): GestureConfig {\n  const derivedConfig = { ...defaultConfig, ...config }\n  const { domTarget } = derivedConfig\n  const realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  derivedConfig.domTarget = realDomTarget\n\n  return derivedConfig\n}\n"]},"metadata":{},"sourceType":"module"}